import { useState, useEffect, useMemo, useRef, useCallback } from 'react';
import { motion, AnimatePresence } from 'motion/react';
import { 
  Target, 
  BookOpen, 
  Puzzle, 
  Key, 
  Trophy, 
  Star,
  CheckCircle,
  Circle,
  Sparkles,
  List,
  FileText,
  Layers,
  Home,
  ChevronRight,
  Gamepad2,
  ArrowLeft
} from 'lucide-react';
import { BackButton } from './BackButton';
import { QuizStatusUpdate } from './QuizStatusUpdate';
import { WordListScreen } from './WordListScreen';
import { FlashcardScreen } from './FlashcardScreen';
import { projectId, publicAnonKey } from '../utils/supabase/info';
import { PDFPrintScreen } from './PDFPrintScreen';
import { MatchQuizLayout } from './quizLayouts/MatchQuizLayout';
import { ArcadeQuizLayout } from './quizLayouts/ArcadeQuizLayout';
import { NormalQuizLayout } from './quizLayouts/NormalQuizLayout';
import {
  subjectStages,
  subjectNames,
  MIN_MATCH_WORDS,
  stageModeAvailability,
  buildQuestionBank,
  shuffleArray,
  normalizeWordForQuiz,
  removeParentheticalHints,
  maskSentence,
  cloneQuestion,
  type Question,
  type Stage,
  type NormalizedWord
} from '../utils/quiz';


interface GameMapQuizScreenProps {
  onBack: () => void;
  onBackToHome?: () => void;
  onXPGain: (points: number) => void;
  userXP: number;
  selectedSubject?: {
    id: string;
    name: string;
    description: string;
    progress: number;
    icon: React.ReactNode;
    color: string;
  };
  vocabularyTitle?: string;
  vocabularyWords?: any[]; // Pre-loaded words from parent
  onQuizCompletion: (data: {
    xpGained: number;
    completionTime: string;
    accuracy: number;
    totalQuestions: number;
    correctAnswers: number;
    stageName: string;
  }) => void;
  onWrongAnswer?: (wordId: string) => void;
  onAddToStarred?: (wordId: string) => void;
  onMoveToGraveyard?: (wordId: string) => void;
  onDeletePermanently?: (wordId: string) => void;
  starredWordIds?: string[];
  graveyardWordIds?: string[];
  wrongAnswersWordIds?: string[];
  getAuthToken?: () => string;
  onRefreshVocabulary?: () => Promise<void>;
  vocabularyId?: string;
  isLoading?: boolean;
}

export interface Stage {
  id: number;
  title: string;
  icon: React.ReactNode;
  status: 'locked' | 'current' | 'completed';
  xpReward: number;
}

type QuestionType = 'multiple-choice' | 'multi-select' | 'sentence';

export interface Question {
  id: number;
  type?: QuestionType;
  question: string;
  options: string[];
  correctAnswer?: number;
  correctAnswers?: number[];
  explanation?: string;
  word?: string;
  wordId?: string;
  sentenceData?: {
    english: string;
    translation?: string;
  };
}

interface NormalizedWord {
  id: string;
  word: string;
  meaning: string;
  translation?: string;
  example?: string;
  derivatives: Array<{ word: string; meaning: string }>;
  synonyms: string[];
  antonyms: string[];
}

const parseListField = (value: any): string[] => {
  if (!value) return [];
  if (Array.isArray(value)) {
    return value
      .map((entry) => (typeof entry === 'string' ? entry : entry?.word || ''))
      .map((entry) => entry.trim())
      .filter(Boolean);
  }
  if (typeof value === 'string') {
    return value
      .split(/[,;/]/)
      .map((item) => item.trim())
      .filter(Boolean);
  }
  return [];
};

const parseDerivativeField = (value: any): Array<{ word: string; meaning: string }> => {
  if (!value) return [];
  if (Array.isArray(value)) {
    return value
      .map((entry) => {
        if (typeof entry === 'string') {
          const [word, meaning] = entry.split(':').map((item) => item.trim());
          return { word, meaning: meaning || '' };
        }
        return {
          word: entry?.word?.trim() || '',
          meaning: entry?.meaning?.trim() || ''
        };
      })
      .filter((entry) => entry.word);
  }
  if (typeof value === 'string') {
    return value
      .split(/[,;]/)
      .map((segment) => {
        const [word, meaning] = segment.split(':').map((item) => item.trim());
        return { word, meaning: meaning || '' };
      })
      .filter((entry) => entry.word);
  }
  return [];
};

const normalizeWordForQuiz = (word: any): NormalizedWord | null => {
  const normalizedWord = word?.word || word?.term;
  if (!normalizedWord) return null;

  const normalizedId = word?.id || normalizedWord;
  if (!normalizedId) return null;

  return {
    id: String(normalizedId),
    word: normalizedWord,
    meaning: word?.meaning || word?.translation || '',
    translation: word?.translation || '',
    example: word?.example || word?.example_sentence || '',
    derivatives: parseDerivativeField(word?.derivatives),
    synonyms: parseListField(word?.synonyms),
    antonyms: parseListField(word?.antonyms)
  };
};

const removeParentheticalHints = (text: string) => {
  if (!text) return text;
  return text.replace(/\([^)]*\)/g, '_____');
};

// Legacy subject questions removed - now using utils/quiz

// Default to math questions if no subject is specified

// Legacy stage configurations removed - now using utils/quiz

const MIN_MATCH_WORDS = 5;

const stageModeAvailability: Record<number, Array<'normal' | 'match' | 'game'>> = {
  1: ['normal', 'match'],
  2: ['normal', 'match'],
  3: ['normal'],
  4: ['normal'],
  5: ['normal']
};

const shuffleArray = <T,>(array: T[]): T[] => {
  return [...array].sort(() => Math.random() - 0.5);
};

const generateMeaningQuestions = (words: any[], limit = 20): Question[] => {
  const candidates = words.filter((word) => word?.id && word?.word && word?.meaning);
  if (!candidates.length) return [];

  const meaningPool = candidates.map((word) => word.meaning);
  let idx = 1;
  const questions: Question[] = [];

  shuffleArray(candidates).forEach((word) => {
    if (questions.length >= limit) return;
    const distractors = shuffleArray(
      meaningPool.filter((meaning) => meaning && meaning !== word.meaning)
    ).slice(0, 3);
    if (distractors.length < 3) return;
    const options = shuffleArray([word.meaning, ...distractors]);
    questions.push({
      id: idx++,
      type: 'multiple-choice',
      wordId: word.id,
      word: word.word,
      question: `${word.word}Ïùò ÎúªÏúºÎ°ú Í∞ÄÏû• ÏïåÎßûÏùÄ Í≤ÉÏùÄ?`,
      options,
      correctAnswer: options.indexOf(word.meaning),
      explanation: `${word.word}: ${word.meaning}`
    });
  });

  return questions;
};

const generateDerivativeQuestions = (words: any[], limit = 12): Question[] => {
  const derivativeEntries = words.flatMap((word: any) =>
    (word?.derivatives || []).map((der: any) => ({
      wordId: word.id,
      root: word.word,
      derivative: der?.word,
      meaning: der?.meaning
    }))
  ).filter((entry) => entry.wordId && entry.derivative && entry.meaning);

  if (!derivativeEntries.length) return [];

  const meaningPool = derivativeEntries.map((entry) => entry.meaning);
  let idx = 1;
  const questions: Question[] = [];

  shuffleArray(derivativeEntries).forEach((entry) => {
    if (questions.length >= limit) return;
    const distractors = shuffleArray(
      meaningPool.filter((meaning) => meaning && meaning !== entry.meaning)
    ).slice(0, 3);
    if (distractors.length < 3) return;
    const options = shuffleArray([entry.meaning, ...distractors]);
    questions.push({
      id: idx++,
      type: 'multiple-choice',
      wordId: entry.wordId,
      question: `'${entry.root}'Ïùò ÌååÏÉùÏñ¥ '${entry.derivative}' ÎúªÏùÄ?`,
      options,
      correctAnswer: options.indexOf(entry.meaning),
      explanation: `${entry.derivative} (${entry.root}): ${entry.meaning}`
    });
  });

  return questions;
};

const generateSynAntQuestions = (words: any[], limit = 12): Question[] => {
  const questions: Question[] = [];
  const candidates = words.filter(
    (word) =>
      word?.id && ((word?.synonyms?.length || 0) >= 2 || (word?.antonyms?.length || 0) >= 2)
  );
  const fallbackOptions = words.map((word) => word.word).filter(Boolean);

  shuffleArray(candidates).forEach((word) => {
    if (questions.length >= limit) return;
    const useSynonym =
      (word.synonyms?.length || 0) >= 2 &&
      ((word.antonyms?.length || 0) < 2 || Math.random() > 0.5);
    const pool = useSynonym ? (word.synonyms || []) : (word.antonyms || []);
    if (pool.length < 2) return;

    const targetCount = Math.min(pool.length, 3);
    const requiredCount = Math.max(2, targetCount);
    const correctWords = shuffleArray(pool).slice(0, requiredCount);

    const distractorPool = shuffleArray(
      [
        ...fallbackOptions,
        ...(words.flatMap((w) => (useSynonym ? w.synonyms || [] : w.antonyms || [])) as string[])
      ].filter((item) => item && !correctWords.includes(item))
    );

    const mergedOptions: string[] = [...correctWords];
    distractorPool.forEach((value) => {
      if (mergedOptions.length >= 8) return;
      if (!mergedOptions.includes(value)) mergedOptions.push(value);
    });

    if (mergedOptions.length < 8) return;

    const distractorOnly = mergedOptions.filter((option) => !correctWords.includes(option));
    const options = shuffleArray([
      ...correctWords,
      ...shuffleArray(distractorOnly).slice(0, 8 - correctWords.length)
    ]);

    const correctIndexes = options.reduce<number[]>((acc, option, index) => {
      if (correctWords.includes(option)) acc.push(index);
      return acc;
    }, []);

    questions.push({
      id: questions.length + 1,
      type: 'multi-select',
      wordId: word.id,
      question: `'${word.word}'Ïùò ${useSynonym ? 'ÎèôÏùòÏñ¥' : 'Î∞òÏùòÏñ¥'}Î•º Î™®Îëê ÏÑ†ÌÉùÌïòÏÑ∏Ïöî (${correctWords.length}Í∞ú)`,
      options,
      correctAnswers: correctIndexes,
      explanation: `${useSynonym ? 'ÎèôÏùòÏñ¥' : 'Î∞òÏùòÏñ¥'}: ${correctWords.join(', ')}`
    });
  });

  return questions;
};

const maskSentence = (sentence: string, target: string) => {
  if (!sentence || !target) return sentence;
  const regex = new RegExp(target, 'gi');
  return sentence.replace(regex, '_____');
};

const generateSentenceQuestions = (words: any[], limit = 12): Question[] => {
  const candidates = words.filter((word) => word?.id && word?.word && word?.example);
  if (!candidates.length) return [];

  const wordPool = words.map((word) => word.word).filter(Boolean);
  let idx = 1;
  const questions: Question[] = [];

  shuffleArray(candidates).forEach((word) => {
    if (questions.length >= limit) return;
    if (!word.word || !word.example) return;
    const distractors = shuffleArray(
      wordPool.filter((entry) => entry && entry !== word.word)
    ).slice(0, 3);
    if (distractors.length < 3) return;
    const options = shuffleArray([word.word, ...distractors]);

    questions.push({
      id: idx++,
      type: 'sentence',
      wordId: word.id,
      question: 'ÎπàÏπ∏ÏùÑ Ï±ÑÏö∏ ÏïåÎßûÏùÄ Îã®Ïñ¥Î•º Í≥†Î•¥ÏÑ∏Ïöî.',
      options,
      correctAnswer: options.indexOf(word.word),
      explanation: `${word.word}: ${word.meaning || ''}`,
      word: word.word,
      sentenceData: {
        english: removeParentheticalHints(maskSentence(word.example, word.word)),
        translation: word.translation
          ? removeParentheticalHints(maskSentence(word.translation, word.word))
          : removeParentheticalHints(word.translation || word.meaning || '')
      }
    });
  });

  return questions;
};

const cloneQuestion = (question: Question, newId: number): Question => ({
  ...question,
  id: newId,
  options: [...question.options],
  correctAnswers: question.correctAnswers ? [...question.correctAnswers] : undefined,
  wordId: question.wordId,
  sentenceData: question.sentenceData ? { ...question.sentenceData } : undefined
});

const generateAllInOneQuestions = (
  sources: {
    meaningQuestions: Question[];
    derivativeQuestions: Question[];
    synAntQuestions: Question[];
    sentenceQuestions: Question[];
  },
  limit = 30
): Question[] => {
  const pool = [
    ...sources.meaningQuestions,
    ...sources.derivativeQuestions,
    ...sources.synAntQuestions,
    ...sources.sentenceQuestions
  ];

  if (!pool.length) return [];

  const questions: Question[] = [];
  const shuffled = shuffleArray(pool);
  let index = 1;

  for (const question of shuffled) {
    if (questions.length >= limit) break;
    questions.push(cloneQuestion(question, index++));
  }

  while (questions.length < limit && sources.meaningQuestions.length) {
    const fallback = sources.meaningQuestions[questions.length % sources.meaningQuestions.length];
    questions.push(cloneQuestion(fallback, questions.length + 1));
  }

  return questions;
};

const buildQuestionBank = (words: any[]): Record<number, Question[]> | null => {
  if (!words || !words.length) return null;

  const normalizedWords = words
    .map(normalizeWordForQuiz)
    .filter((word): word is NormalizedWord => !!word);
  if (!normalizedWords.length) return null;

  const meaningQuestions = generateMeaningQuestions(normalizedWords, 20);
  if (!meaningQuestions.length) return null;

  const derivativeQuestions = generateDerivativeQuestions(normalizedWords, 12);
  const synAntQuestions = generateSynAntQuestions(normalizedWords, 12);
  const sentenceQuestions = generateSentenceQuestions(normalizedWords, 12);
  const allInOneQuestions = generateAllInOneQuestions(
    { meaningQuestions, derivativeQuestions, synAntQuestions, sentenceQuestions },
    30
  );

  return {
    1: meaningQuestions,
    2: derivativeQuestions.length ? derivativeQuestions : meaningQuestions,
    3: synAntQuestions.length ? synAntQuestions : meaningQuestions,
    4: sentenceQuestions.length ? sentenceQuestions : meaningQuestions,
    5: allInOneQuestions.length ? allInOneQuestions : meaningQuestions
  };
};

export function GameMapQuizScreen({
  onBack,
  onBackToHome,
  onXPGain,
  userXP: _userXP,
  selectedSubject,
  vocabularyTitle,
  vocabularyWords: propsVocabularyWords,
  onQuizCompletion,
  onWrongAnswer,
  onAddToStarred,
  onMoveToGraveyard,
  onDeletePermanently,
  starredWordIds = [],
  graveyardWordIds = [],
  wrongAnswersWordIds = [],
  getAuthToken,
  onRefreshVocabulary,
  vocabularyId,
  isLoading
}: GameMapQuizScreenProps) {
  // Get subject-specific stages and questions
  const subjectId = selectedSubject?.id || 'math';
  const journeyName = vocabularyTitle || subjectNames[subjectId] || "Math Journey";
  
  const [stages, setStages] = useState<Stage[]>(subjectStages[subjectId] || subjectStages.math);

  const [currentStage, setCurrentStage] = useState<number | null>(null);
  const [currentQuestion, setCurrentQuestion] = useState(0);
  const [selectedAnswers, setSelectedAnswers] = useState<number[]>([]);
  const [showFeedback, setShowFeedback] = useState(false);
  const [lastAnswerCorrect, setLastAnswerCorrect] = useState<boolean | null>(null);
  const [stageScore, setStageScore] = useState(0);
  const [showStageComplete, setShowStageComplete] = useState(false);
  const [showVictory, setShowVictory] = useState(false);
  const [startTime, setStartTime] = useState<Date | null>(null);
  const [correctAnswersCount, setCorrectAnswersCount] = useState(0);
  const [showQuizModeSelector, setShowQuizModeSelector] = useState(false);
  const [selectedQuizMode, setSelectedQuizMode] = useState<'normal' | 'match' | 'game'>('normal');
  const [matchGameType, setMatchGameType] = useState<'card-match-word' | 'card-match-meaning' | null>(null);
  const [gameType, setGameType] = useState<'fall' | 'speed' | null>(null);
  const [pendingStageId, setPendingStageId] = useState<number | null>(null);
  const canOpenPdfExport = !!selectedSubject;
  const [activeTab, setActiveTab] = useState<'word-list' | 'quiz-map' | 'flashcards' | 'pdf-print'>('word-list');
  const isStarredVocabulary = selectedSubject?.id === 'starred';
  const [shuffledQuestions, setShuffledQuestions] = useState<Record<number, Question[]>>({});
  const vocabularyCacheRef = useRef<Record<string, any[]>>({});
  const loadingVocabularyIdRef = useRef<string | null>(null);
  const vocabularyVersionRef = useRef<Record<string, number>>({});
  const loadedVersionRef = useRef<Record<string, number>>({});
  const requestPromisesRef = useRef<Record<string, Promise<any[]>>>({});
  const [refreshCounter, setRefreshCounter] = useState(0);
  const specialSignatureRef = useRef({
    starred: '',
    graveyard: '',
    wrongAnswers: ''
  });
  const shuffleStageQuestions = useCallback((stageId: number, bank: Record<number, Question[]>) => {
    const baseQuestions = bank[stageId] || [];
    if (!baseQuestions.length) return;
    const shuffled = shuffleArray(baseQuestions);
    setShuffledQuestions((prev) => ({
      ...prev,
      [stageId]: shuffled
    }));
  }, []);

  const invalidateVocabulary = useCallback((vocabId: string) => {
    if (!vocabId) return;
    delete vocabularyCacheRef.current[vocabId];
    delete loadedVersionRef.current[vocabId];
    Object.keys(requestPromisesRef.current).forEach((key) => {
      if (key.startsWith(`${vocabId}:`)) {
        delete requestPromisesRef.current[key];
      }
    });
    vocabularyVersionRef.current[vocabId] = (vocabularyVersionRef.current[vocabId] || 0) + 1;
    setRefreshCounter((prev) => prev + 1);
  }, []);

  useEffect(() => {
    const signature = (starredWordIds || []).join('|');
    if (signature === specialSignatureRef.current.starred) return;
    specialSignatureRef.current.starred = signature;
    invalidateVocabulary('starred');
  }, [starredWordIds, invalidateVocabulary]);

  useEffect(() => {
    const signature = (graveyardWordIds || []).join('|');
    if (signature === specialSignatureRef.current.graveyard) return;
    specialSignatureRef.current.graveyard = signature;
    invalidateVocabulary('graveyard');
  }, [graveyardWordIds, invalidateVocabulary]);

  useEffect(() => {
    const signature = (wrongAnswersWordIds || []).join('|');
    if (signature === specialSignatureRef.current.wrongAnswers) return;
    specialSignatureRef.current.wrongAnswers = signature;
    invalidateVocabulary('wrong-answers');
  }, [wrongAnswersWordIds, invalidateVocabulary]);

  // Refresh vocabulary function for WordListScreen
  const refreshVocabulary = useCallback(async () => {
    console.log('[GameMapQuizScreen] refreshVocabulary called');
    // If parent provided onRefreshVocabulary, use that
    if (onRefreshVocabulary) {
      console.log('[GameMapQuizScreen] Using parent onRefreshVocabulary');
      await onRefreshVocabulary();
      return;
    }
    // Otherwise, invalidate our own cache
    console.log('[GameMapQuizScreen] Using local invalidateVocabulary for:', vocabularyId);
    if (vocabularyId) {
      invalidateVocabulary(vocabularyId);
    }
  }, [onRefreshVocabulary, vocabularyId, invalidateVocabulary]);

  // Í∞Å Ïä§ÌÖåÏù¥ÏßÄÎ≥Ñ Î™®ÎìúÎ≥Ñ ÏôÑÎ£å Ïó¨Î∂Ä Ï∂îÏ†Å
  const [completedModes, setCompletedModes] = useState<Record<number, Set<'normal' | 'match' | 'game'>>>({
    1: new Set(),
    2: new Set(),
    3: new Set(),
    4: new Set(),
    5: new Set()
  });

  // State for vocabulary words
  const [vocabularyWords, setVocabularyWords] = useState<any[]>([]);
  const [isLoadingWords, setIsLoadingWords] = useState(true);
  const [showSentenceTranslation, setShowSentenceTranslation] = useState(false);
  const dynamicQuestionBank = useMemo<Record<number, Question[]> | null>(
    () => buildQuestionBank(vocabularyWords),
    [vocabularyWords]
  );
  const fallbackQuestionBank = useMemo<Record<number, Question[]>>(
    () => subjectQuestions[subjectId] || subjectQuestions.math,
    [subjectId]
  );
  const questionBank = useMemo<Record<number, Question[]>>(() => {
    if (dynamicQuestionBank) {
      return dynamicQuestionBank;
    }
    if (vocabularyWords.length > 0) {
      // Words are loaded but we couldn't build quizzes (e.g., insufficient data). Avoid sample questions.
      return {};
    }
    return fallbackQuestionBank;
  }, [dynamicQuestionBank, fallbackQuestionBank, vocabularyWords.length]);
  const matchWordPools = useMemo<Record<number, any[]>>(() => {
    const derivativePool = vocabularyWords
      .flatMap((word: any) =>
        (word?.derivatives || []).map((der: any, index: number) => ({
          id: `${word.id}-derivative-${index}`,
          word: der?.word || der?.term || '',
          meaning: der?.meaning || '',
        }))
      )
      .filter((entry) => entry.word && entry.meaning);

    return {
      1: vocabularyWords,
      2: derivativePool.length ? derivativePool : vocabularyWords,
      3: vocabularyWords,
      4: vocabularyWords,
      5: vocabularyWords
    };
  }, [vocabularyWords]);

  const getMatchWordsForStage = useCallback(
    (stageId: number) => {
      const pool = matchWordPools[stageId];
      return pool && pool.length ? pool : vocabularyWords;
    },
    [matchWordPools, vocabularyWords]
  );

  // Load vocabulary words from server
  useEffect(() => {
    // ‚úÖ If parent provided vocabularyWords, use them directly
    if (propsVocabularyWords && propsVocabularyWords.length > 0) {
      console.log(`[GameMapQuizScreen] ‚úÖ Using ${propsVocabularyWords.length} words from props (unit-filtered)`);
      setVocabularyWords(propsVocabularyWords);
      setIsLoadingWords(false);
      return;
    }

    const vocabId = selectedSubject?.id;

    if (!vocabId) {
      console.log('[GameMapQuizScreen] ‚ùå No selectedSubject.id, using sample words');
      setVocabularyWords([]);
      setIsLoadingWords(false);
      return;
    }

    const version = vocabularyVersionRef.current[vocabId] || 0;
    const loadKey = `${vocabId}:${version}`;
    const cachedWords = vocabularyCacheRef.current[vocabId];

    if (cachedWords && loadedVersionRef.current[vocabId] === version) {
      setVocabularyWords(cachedWords);
      setIsLoadingWords(false);
      return;
    }

    const reusePromise = requestPromisesRef.current[loadKey];
    if (reusePromise) {
      setIsLoadingWords(true);
      let isStale = false;
      reusePromise
        .then((words) => {
          if (!isStale) {
            setVocabularyWords(words);
            setIsLoadingWords(false);
          }
        })
        .catch((error) => {
          if (!isStale) {
            console.error('[GameMapQuizScreen] ‚ùå Error loading vocabulary words:', error);
            setIsLoadingWords(false);
          }
        });
      return () => {
        isStale = true;
      };
    }

    if (loadingVocabularyIdRef.current === loadKey) {
      return;
    }

    let isCancelled = false;
    const fetchPromise = (async () => {
      const isSpecialVocabulary = ['starred', 'graveyard', 'wrong-answers'].includes(vocabId);

      let endpoint = '';
      if (isSpecialVocabulary) {
        endpoint = `https://${projectId}.supabase.co/functions/v1/server/${vocabId}`;
      } else {
        endpoint = `https://${projectId}.supabase.co/functions/v1/server/user-vocabularies/${vocabId}`;
      }

      const authToken = getAuthToken ? getAuthToken() : publicAnonKey;
      const response = await fetch(endpoint, {
        headers: {
          'Authorization': `Bearer ${authToken}`
        }
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(errorText || 'Failed to load vocabulary words');
      }

      const data = await response.json();
      console.log('[GameMapQuizScreen] üì¶ API response:', data);
      const allWords: any[] = [];

      if (isSpecialVocabulary) {
        if (data.words && Array.isArray(data.words)) {
          allWords.push(...data.words);
        } else if (Array.isArray(data)) {
          allWords.push(...data);
        }
      } else {
        if (data.units && Array.isArray(data.units)) {
          data.units.forEach((unit: any) => {
            if (unit.words && Array.isArray(unit.words)) {
              allWords.push(...unit.words);
            }
          });
        }
      }

      console.log(`[GameMapQuizScreen] ‚úÖ Loaded ${allWords.length} words from vocabulary ${vocabId}`);
      console.log('[GameMapQuizScreen] üìù First word:', allWords[0]);
      vocabularyCacheRef.current[vocabId] = allWords;
      loadedVersionRef.current[vocabId] = version;
      return allWords;
    })();

    requestPromisesRef.current[loadKey] = fetchPromise;
    loadingVocabularyIdRef.current = loadKey;
    setIsLoadingWords(true);
    console.log('[GameMapQuizScreen] üìö Loading words for vocabulary ID:', vocabId);

    fetchPromise
      .then((words) => {
        if (!isCancelled) {
          setVocabularyWords(words);
        }
      })
      .catch((error) => {
        if (!isCancelled) {
          console.error('[GameMapQuizScreen] ‚ùå Error loading vocabulary words:', error);
        }
      })
      .finally(() => {
        if (!isCancelled) {
          setIsLoadingWords(false);
        }
        if (loadingVocabularyIdRef.current === loadKey) {
          loadingVocabularyIdRef.current = null;
        }
        delete requestPromisesRef.current[loadKey];
      });

    return () => {
      isCancelled = true;
    };
  }, [propsVocabularyWords, selectedSubject?.id, getAuthToken, refreshCounter]);


  useEffect(() => {
    setShowSentenceTranslation(false);
  }, [currentQuestion, currentStage]);

  const handleStageClick = (stageId: number) => {
    const stage = stages.find(s => s.id === stageId);
    if (!stage) return;

    const modes = stageModeAvailability[stageId] || ['normal'];

    if (modes.length === 1) {
      const mode = modes[0];
      if (mode === 'match') {
        const poolLength = getMatchWordsForStage(stageId).length;
        if (poolLength < MIN_MATCH_WORDS) {
          alert(`Îß§Ïπò Î™®ÎìúÎ•º Ïù¥Ïö©ÌïòÎ†§Î©¥ ÏµúÏÜå ${MIN_MATCH_WORDS}Í∞ú Ïù¥ÏÉÅÏùò Îã®Ïñ¥Í∞Ä ÌïÑÏöîÌï¥Ïöî.`);
          return;
        }
      }
      setSelectedQuizMode(mode);
      startQuiz(stageId, mode);
      return;
    }

    setPendingStageId(stageId);
    setShowQuizModeSelector(true);
  };

  const startQuiz = (stageId: number, mode: 'normal' | 'match' | 'game') => {
    if (mode === 'match') {
      const poolLength = getMatchWordsForStage(stageId).length;
      if (poolLength < MIN_MATCH_WORDS) {
        alert(`Îß§Ïπò Î™®ÎìúÎ•º Ïù¥Ïö©ÌïòÎ†§Î©¥ ÏµúÏÜå ${MIN_MATCH_WORDS}Í∞ú Ïù¥ÏÉÅÏùò Îã®Ïñ¥Í∞Ä ÌïÑÏöîÌï¥Ïöî.`);
        return;
      }
    }

    if (mode !== 'match') {
      const stageQuestions = questionBank[stageId] || [];
      if (!stageQuestions.length) {
        if (vocabularyWords.length > 0) {
          const stageTitle = stages.find((s) => s.id === stageId)?.title || 'Ïù¥ ÌÄ¥Ï¶à';
          alert(`${stageTitle}Î•º ÎßåÎì§ Îã®Ïñ¥Í∞Ä Î∂ÄÏ°±Ìï¥Ïöî. Îã®Ïñ¥Ïû•ÏùÑ Ï°∞Í∏à Îçî Ï±ÑÏö¥ ÌõÑ Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.`);
        }
        return;
      }
    }

    setCurrentStage(stageId);
    setCurrentQuestion(0);
    setStageScore(0);
    setSelectedAnswers([]);
    setShowFeedback(false);
    setLastAnswerCorrect(null);
    setStartTime(new Date());
    setCorrectAnswersCount(0);
    setSelectedQuizMode(mode);
    setShowQuizModeSelector(false);
    setPendingStageId(null);
    setShowSentenceTranslation(false);
    shuffleStageQuestions(stageId, questionBank);

    // Set game type once when starting (not on every render)
    if (mode === 'match') {
      setMatchGameType('card-match-word');
    } else if (mode === 'game') {
      setGameType(Math.random() > 0.5 ? 'fall' : 'speed');
    }
  };

  const handleVocabularyGameCompletion = useCallback(
    (correctCount: number, stage?: Stage) => {
      setStageScore(correctCount);
      setCorrectAnswersCount(correctCount);
      setShowStageComplete(true);

      if (!currentStage) return;

      if (correctCount >= 3) {
        setStages((prevStages) =>
          prevStages.map((s) => {
            if (s.id === currentStage) {
              return { ...s, status: 'completed' as const };
            }
            if (s.id === currentStage + 1 && s.status === 'locked') {
              return { ...s, status: 'current' as const };
            }
            return s;
          })
        );
      }
    },
    [currentStage]
  );

  const handleAnswerSelect = (answerIndex: number) => {
    if (showFeedback) return;
    const stageQuestions = currentStage
      ? shuffledQuestions[currentStage] || questionBank[currentStage]
      : null;
    const question = stageQuestions ? stageQuestions[currentQuestion] : null;
    if (!question) return;

    if (question.type === 'multi-select') {
      setSelectedAnswers((prev) =>
        prev.includes(answerIndex)
          ? prev.filter((value) => value !== answerIndex)
          : [...prev, answerIndex]
      );
    } else {
      const nextSelection = [answerIndex];
      setSelectedAnswers(nextSelection);
      // Slight delay to let selection state render before auto submit
      setTimeout(() => {
        handleSubmitAnswer(nextSelection);
      }, 120);
    }
  };

  const handleSubmitAnswer = (overrideAnswers?: number[]) => {
    if (!currentStage) return;

    const questions =
      shuffledQuestions[currentStage] ||
      questionBank[currentStage] ||
      [];
    const currentQ = questions[currentQuestion];
    const answers = overrideAnswers ?? selectedAnswers;
    if (!currentQ || answers.length === 0) return;

    let isCorrect = false;
    if (currentQ.type === 'multi-select' && currentQ.correctAnswers) {
      const sortedSelected = [...answers].sort();
      const sortedCorrect = [...currentQ.correctAnswers].sort();
      isCorrect =
        sortedSelected.length === sortedCorrect.length &&
        sortedSelected.every((value, index) => value === sortedCorrect[index]);
    } else if (typeof currentQ.correctAnswer === 'number') {
      isCorrect = answers[0] === currentQ.correctAnswer;
    }
    
    setShowFeedback(true);
    setLastAnswerCorrect(isCorrect);
    
    if (isCorrect) {
      setStageScore(prev => prev + 1);
      setCorrectAnswersCount(prev => prev + 1);
    } else {
      // ÌãÄÎ¶∞ ÎãµÎ≥Ä Ï∂îÏ†Å - ÏßàÎ¨∏ IDÎ•º Îã®Ïñ¥ IDÎ°ú ÏÇ¨Ïö©
      const wrongId = currentQ.wordId || currentQ.word;
      if (onWrongAnswer && wrongId) {
        onWrongAnswer(wrongId);
      }
    }

    setTimeout(() => {
      if (currentQuestion < questions.length - 1) {
        setCurrentQuestion(prev => prev + 1);
        setSelectedAnswers([]);
        setShowFeedback(false);
        setLastAnswerCorrect(null);
        setShowSentenceTranslation(false);
      } else {
        setSelectedAnswers([]);
        setShowFeedback(false);
        setLastAnswerCorrect(null);
        setShowSentenceTranslation(false);
        completeStage();
      }
    }, 2500);
  };

  const completeStage = () => {
    if (!currentStage) return;
    
    const stage = stages.find(s => s.id === currentStage);
    if (!stage) return;

    // ÌòÑÏû¨ Î™®ÎìúÎ•º ÏôÑÎ£åÎ°ú ÌëúÏãú
    setCompletedModes(prev => {
      const updated = { ...prev };
      if (!updated[currentStage]) {
        updated[currentStage] = new Set();
      }
      updated[currentStage].add(selectedQuizMode);
      return updated;
    });

    // Mark current stage as completed (ÌïòÎÇòÎùºÎèÑ ÏôÑÎ£åÌïòÎ©¥ completed)
    setStages(prev => prev.map(s => {
      if (s.id === currentStage) {
        return { ...s, status: 'completed' as const };
      }
      if (s.id === currentStage + 1) {
        return { ...s, status: 'current' as const };
      }
      return s;
    }));

    // Auto-advance to next stage or return to map
    if (currentStage === 5) {
      // Calculate completion stats for the entire journey
      const endTime = new Date();
      const completionTimeMs = startTime ? endTime.getTime() - startTime.getTime() : 0;
      const minutes = Math.floor(completionTimeMs / 60000);
      const seconds = Math.floor((completionTimeMs % 60000) / 1000);
      const completionTime = `${minutes}:${seconds.toString().padStart(2, '0')}`;

      const totalQuestions = Object.values(questionBank).flat().length;
      const accuracy = Math.round((correctAnswersCount / totalQuestions) * 100);

      // Trigger full journey completion screen
      onQuizCompletion({
        xpGained: 0,
        completionTime,
        accuracy,
        totalQuestions,
        correctAnswers: correctAnswersCount,
        stageName: journeyName
      });
    } else {
      // Auto-advance to next stage after a short delay
      setTimeout(() => {
        const nextStage = stages.find(s => s.id === currentStage + 1);
        if (nextStage && nextStage.status !== 'locked') {
          handleStageClick(currentStage + 1);
        } else {
          resetToMap();
        }
      }, 800);
    }
  };

  const resetToMap = () => {
    setCurrentStage(null);
    setShowStageComplete(false);
    setCurrentQuestion(0);
    setSelectedAnswers([]);
    setShowFeedback(false);
    setLastAnswerCorrect(null);
    setShowSentenceTranslation(false);
    setStageScore(0);
  };

  const resetGame = () => {
    setStages(subjectStages[subjectId] || subjectStages.math);
    setShowVictory(false);
    setSessionXP(0);
    resetToMap();
  };





  if (currentStage) {
    const stage = stages.find(s => s.id === currentStage);
    
    // Check if we're in Match or Game mode and should show vocabulary games
    if (selectedQuizMode === 'match') {
      const matchWords = currentStage ? getMatchWordsForStage(currentStage) : vocabularyWords;
      if (!matchWords.length) {
        return (
          <div className="min-h-screen flex items-center justify-center text-[#091A7A]">
            <p>Îß§Ïπò Í≤åÏûÑÏùÑ ÏßÑÌñâÌï† Îã®Ïñ¥Í∞Ä Î∂ÄÏ°±Ìï©ÎãàÎã§.</p>
          </div>
        );
      }
      return (
        <MatchQuizLayout
          words={matchWords}
          matchGameType={matchGameType || 'card-match-word'}
          onBack={resetToMap}
          onBackToHome={onBackToHome}
          onComplete={(_, correctCount) => handleVocabularyGameCompletion(correctCount, stage)}
          onWrongAnswer={onWrongAnswer}
          stage={stage}
          journeyName={journeyName}
          wordCount={matchWords.length}
          isStarredVocabulary={isStarredVocabulary}
        />
      );
    }
    
    if (selectedQuizMode === 'game' && vocabularyWords.length > 0) {
      return (
        <ArcadeQuizLayout
          words={vocabularyWords}
          gameType={gameType || 'fall'}
          onBack={resetToMap}
          onComplete={(_, correctCount) => handleVocabularyGameCompletion(correctCount, stage)}
          onWrongAnswer={onWrongAnswer}
        />
      );
    }
    
    // Normal quiz mode
    const questions = currentStage
      ? shuffledQuestions[currentStage] || questionBank[currentStage] || []
      : [];
    const currentQ = questions[currentQuestion];

    if (!currentQ) {
      return (
        <div className="min-h-screen flex items-center justify-center text-[#091A7A]">
          <p>Ï§ÄÎπÑÎêú Î¨∏Ï†úÍ∞Ä ÏóÜÏäµÎãàÎã§. Îã®Ïñ¥Î•º Îçî Ï∂îÍ∞ÄÌï¥ Ï£ºÏÑ∏Ïöî.</p>
        </div>
      );
    }

    const isMultiSelect = currentQ.type === 'multi-select';
    const isSentenceQuestion = currentQ.type === 'sentence' && currentQ.sentenceData;

    return (
      <NormalQuizLayout
        stage={stage}
        currentStageId={currentStage}
        currentQuestionIndex={currentQuestion}
        totalQuestions={questions.length}
        question={currentQ}
        selectedAnswers={selectedAnswers}
        showFeedback={showFeedback}
        lastAnswerCorrect={lastAnswerCorrect}
        isMultiSelect={isMultiSelect}
        isSentenceQuestion={Boolean(isSentenceQuestion)}
        sentenceTranslationVisible={showSentenceTranslation}
        onBack={resetToMap}
        onBackToHome={onBackToHome}
        onAnswerSelect={handleAnswerSelect}
        onToggleSentenceTranslation={() => setShowSentenceTranslation((prev) => !prev)}
        onSubmitAnswer={handleSubmitAnswer}
        journeyName={journeyName}
        wordCount={vocabularyWords.length}
        isStarredVocabulary={isStarredVocabulary}
      />
    );
  }
                    
                    
  return (
    <div className="h-full bg-transparent relative flex flex-col">
      {/* Fixed Header and Tabs Container */}
      <div className={`flex-shrink-0 z-50 pdf-print-overlay bg-gradient-to-b ${isStarredVocabulary ? 'from-[#FFFBEB]/80 to-[#FEF3C7]/70' : 'from-[#D4C5FF] to-transparent'}`}>
        {/* Header */}
        <div className="p-6 pb-3">
          <div className="flex items-center justify-between">
            <BackButton onClick={onBack} />

            <div className="flex-1 mx-4 text-center">
              <h1 style={{ fontSize: '18px', fontWeight: 700, color: isStarredVocabulary ? '#78350F' : '#5B21B6' }}>
                {isStarredVocabulary ? '‚≠ê Starred Words' : journeyName}
              </h1>
              <p style={{ fontSize: '12px', fontWeight: 500, color: isStarredVocabulary ? '#D97706' : '#A78BFA' }}>
                {vocabularyWords.length}Í∞úÏùò Îã®Ïñ¥
              </p>
            </div>

            {/* Home Button */}
            {onBackToHome ? (
              <motion.button
                whileTap={{ scale: 0.95 }}
                onClick={onBackToHome}
                className="w-10 h-10 bg-white/90 backdrop-blur-md rounded-full flex items-center justify-center shadow-card"
              >
                <Home className="w-5 h-5" style={{ color: isStarredVocabulary ? '#78350F' : '#5B21B6' }} />
              </motion.button>
            ) : (
              <div className="w-10 h-10"></div>
            )}
          </div>
        </div>

        {/* Tab Navigation - Fixed at top */}
        <div className="px-4 pb-2">
          <div className="bg-white/90 backdrop-blur-lg rounded-2xl border border-white/40 shadow-lg p-1.5">
          <div className="grid grid-cols-4 gap-1">
            {/* Word List Tab */}
            <motion.button
              whileTap={{ scale: 0.97 }}
              onClick={() => setActiveTab('word-list')}
              className={`py-2.5 px-2 rounded-xl flex flex-col items-center gap-1 transition-all duration-200 ${
                activeTab === 'word-list'
                  ? isStarredVocabulary
                    ? 'bg-gradient-to-br from-[#F59E0B] to-[#FCD34D] shadow-md'
                    : 'bg-gradient-to-br from-[#7C3AED] to-[#A78BFA] shadow-md'
                  : 'hover:bg-white/50'
              }`}
            >
              <List className={`w-4 h-4 ${activeTab === 'word-list' ? 'text-white' : isStarredVocabulary ? 'text-[#D97706]' : 'text-[#7C3AED]'}`} />
              <span className={`text-[10px] font-semibold ${activeTab === 'word-list' ? 'text-white' : isStarredVocabulary ? 'text-[#78350F]' : 'text-[#5B21B6]'}`}>
                Word List
              </span>
            </motion.button>

            {/* Quiz Map Tab */}
            <motion.button
              whileTap={{ scale: 0.97 }}
              onClick={() => setActiveTab('quiz-map')}
              className={`py-2.5 px-2 rounded-xl flex flex-col items-center gap-1 transition-all duration-200 ${
                activeTab === 'quiz-map'
                  ? isStarredVocabulary
                    ? 'bg-gradient-to-br from-[#F59E0B] to-[#FCD34D] shadow-md'
                    : 'bg-gradient-to-br from-[#7C3AED] to-[#A78BFA] shadow-md'
                  : 'hover:bg-white/50'
              }`}
            >
              <Gamepad2 className={`w-4 h-4 ${activeTab === 'quiz-map' ? 'text-white' : isStarredVocabulary ? 'text-[#D97706]' : 'text-[#7C3AED]'}`} />
              <span className={`text-[10px] font-semibold ${activeTab === 'quiz-map' ? 'text-white' : isStarredVocabulary ? 'text-[#78350F]' : 'text-[#5B21B6]'}`}>
                Quiz Map
              </span>
            </motion.button>

            {/* Flash Cards Tab */}
            <motion.button
              whileTap={{ scale: 0.97 }}
              onClick={() => setActiveTab('flashcards')}
              className={`py-2.5 px-2 rounded-xl flex flex-col items-center gap-1 transition-all duration-200 ${
                activeTab === 'flashcards'
                  ? isStarredVocabulary
                    ? 'bg-gradient-to-br from-[#F59E0B] to-[#FCD34D] shadow-md'
                    : 'bg-gradient-to-br from-[#7C3AED] to-[#A78BFA] shadow-md'
                  : 'hover:bg-white/50'
              }`}
            >
              <Layers className={`w-4 h-4 ${activeTab === 'flashcards' ? 'text-white' : isStarredVocabulary ? 'text-[#D97706]' : 'text-[#7C3AED]'}`} />
              <span className={`text-[10px] font-semibold ${activeTab === 'flashcards' ? 'text-white' : isStarredVocabulary ? 'text-[#78350F]' : 'text-[#5B21B6]'}`}>
                Flash Cards
              </span>
            </motion.button>

            {/* PDF Print Tab */}
            <motion.button
              whileTap={{ scale: canOpenPdfExport ? 0.97 : 1 }}
              onClick={() => canOpenPdfExport && setActiveTab('pdf-print')}
              className={`py-2.5 px-2 rounded-xl flex flex-col items-center gap-1 transition-all duration-200 ${
                activeTab === 'pdf-print'
                  ? isStarredVocabulary
                    ? 'bg-gradient-to-br from-[#F59E0B] to-[#FCD34D] shadow-md'
                    : 'bg-gradient-to-br from-[#7C3AED] to-[#A78BFA] shadow-md'
                  : canOpenPdfExport
                  ? 'hover:bg-white/50'
                  : 'opacity-40 cursor-not-allowed'
              }`}
            >
              <FileText className={`w-4 h-4 ${activeTab === 'pdf-print' ? 'text-white' : isStarredVocabulary ? 'text-[#D97706]' : 'text-[#7C3AED]'}`} />
              <span className={`text-[10px] font-semibold ${activeTab === 'pdf-print' ? 'text-white' : isStarredVocabulary ? 'text-[#78350F]' : 'text-[#5B21B6]'}`}>
                PDF Print
              </span>
            </motion.button>
          </div>
        </div>
        </div>
      </div>

      {/* Tab Content */}
      <div className="flex-1 relative z-10 overflow-hidden">
        <AnimatePresence mode="wait">
          {activeTab === 'word-list' && (
            <motion.div
              key="word-list"
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 20 }}
              transition={{ duration: 0.2 }}
              className="h-full"
            >
              <WordListScreen
                onBack={onBack}
                onBackToHome={onBackToHome}
                vocabularyTitle={selectedSubject?.name || "Ïñ¥Ìúò ÌïôÏäµ"}
                unitName="Unit 1"
                vocabularyWords={vocabularyWords}
                starredWordIds={starredWordIds}
                graveyardWordIds={graveyardWordIds}
                wrongAnswersWordIds={wrongAnswersWordIds}
                isLoading={isLoading}
                vocabularyId={vocabularyId}
                onAddToStarred={onAddToStarred}
                onMoveToGraveyard={onMoveToGraveyard}
                onDeletePermanently={onDeletePermanently}
                onStartFlashcards={() => {
                  console.log('[GameMapQuizScreen] üíú Flashcard button clicked in WordList! Setting activeTab to flashcards');
                  setActiveTab('flashcards');
                }}
                onRefreshVocabulary={refreshVocabulary}
                hideHeader={true}
              />
            </motion.div>
          )}

          {activeTab === 'quiz-map' && (
            <motion.div
              key="quiz-map"
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 20 }}
              transition={{ duration: 0.2 }}
              className="h-full overflow-y-auto scrollbar-hide"
            >
              {/* Duolingo-Style Map */}
              <div className="max-w-sm mx-auto relative pt-2 pb-4">
                {/* Elegant Connection Path */}
                <svg
                  className="absolute inset-0 w-full h-full pointer-events-none z-0"
                  viewBox="0 0 300 500"
                  preserveAspectRatio="xMidYMin meet"
                >
                  <defs>
                    <linearGradient id="pathGradientTab" x1="0%" y1="0%" x2="0%" y2="100%">
                      <stop offset="0%" stopColor={isStarredVocabulary ? "#FEF3C7" : "#DDD6FE"} stopOpacity="0.8" />
                      <stop offset="30%" stopColor={isStarredVocabulary ? "#FCD34D" : "#C4B5FD"} stopOpacity="0.5" />
                      <stop offset="70%" stopColor={isStarredVocabulary ? "#F59E0B" : "#A78BFA"} stopOpacity="0.5" />
                      <stop offset="100%" stopColor={isStarredVocabulary ? "#FEF3C7" : "#DDD6FE"} stopOpacity="0.8" />
                    </linearGradient>
                    <filter id="pathGlowTab">
                      <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
                      <feMerge>
                        <feMergeNode in="coloredBlur"/>
                        <feMergeNode in="SourceGraphic"/>
                      </feMerge>
                    </filter>
                  </defs>
                  <motion.path
                    d="M 150 30
                       C 150 45, 120 70, 90 110
                       C 60 150, 140 170, 210 200
                       C 280 230, 180 250, 90 290
                       C 0 330, 120 350, 150 390"
                    stroke="url(#pathGradientTab)"
                    strokeWidth="4"
                    fill="none"
                    strokeLinecap="round"
                    filter="url(#pathGlowTab)"
                    initial={{ pathLength: 0 }}
                    animate={{ pathLength: 1 }}
                    transition={{ duration: 2, ease: "easeInOut" }}
                  />
                </svg>

                {/* Enhanced Stage Nodes */}
                <div className="relative z-10">
                  {stages.map((stage, index) => {
                    const positions = [
                      { x: '50%', y: '30px', transform: 'translateX(-50%)' },
                      { x: '25%', y: '110px', transform: 'translateX(-50%)' },
                      { x: '65%', y: '200px', transform: 'translateX(-50%)' },
                      { x: '25%', y: '290px', transform: 'translateX(-50%)' },
                      { x: '50%', y: '380px', transform: 'translateX(-50%)' },
                    ];

                    const position = positions[index];

                    return (
                      <motion.div
                        key={stage.id}
                        initial={{ opacity: 0, scale: 0.8, y: 30 }}
                        animate={{ opacity: 1, scale: 1, y: 0 }}
                        transition={{
                          delay: index * 0.15,
                          duration: 0.7,
                          ease: [0.34, 1.56, 0.64, 1]
                        }}
                        className="absolute"
                        style={{
                          left: position.x,
                          top: position.y,
                          transform: position.transform,
                        }}
                      >
                        {/* Premium Stage Button */}
                        <motion.button
                          whileTap={{ scale: 0.92 }}
                          onClick={() => handleStageClick(stage.id)}
                          className={`relative w-[72px] h-[72px] rounded-3xl flex items-center justify-center transition-all duration-300 backdrop-blur-lg border-2 ${
                            stage.status === 'completed'
                              ? 'bg-gradient-to-br from-emerald-400 via-emerald-500 to-emerald-600 border-white/30 text-white shadow-xl shadow-emerald-500/40'
                              : stage.status === 'current'
                              ? isStarredVocabulary
                                ? 'bg-gradient-to-br from-[#F59E0B] via-[#FBBF24] to-[#FCD34D] border-white/30 text-white shadow-xl shadow-amber-500/40'
                                : 'bg-gradient-to-br from-[#7C3AED] via-[#8B5CF6] to-[#A78BFA] border-white/30 text-white shadow-xl shadow-purple-500/40'
                              : 'bg-white/70 border-white/50 text-gray-400 shadow-md'
                          }`}
                        >
                          {/* Icon Display */}
                          {stage.status === 'completed' ? (
                            <motion.div
                              initial={{ scale: 0, rotate: -180 }}
                              animate={{ scale: 1, rotate: 0 }}
                              transition={{ delay: 0.4, type: "spring", stiffness: 300, damping: 15 }}
                            >
                              <CheckCircle className="w-8 h-8 drop-shadow-lg" />
                            </motion.div>
                          ) : (
                            <div className="relative">
                              <div className={`w-6 h-6 ${stage.status === 'locked' ? 'opacity-40' : ''}`}>
                                {stage.icon}
                              </div>
                            </div>
                          )}

                          {/* Number Badge */}
                          <div className={`absolute -top-1.5 -right-1.5 w-6 h-6 rounded-full flex items-center justify-center text-xs font-bold shadow-lg ${
                            stage.status === 'completed'
                              ? 'bg-white text-emerald-600'
                              : stage.status === 'current'
                              ? isStarredVocabulary
                                ? 'bg-white text-amber-600'
                                : 'bg-white text-purple-600'
                              : 'bg-gray-200 text-gray-500'
                          }`}>
                            {stage.id}
                          </div>

                          {/* Animated Glow for Current Stage */}
                          {stage.status === 'current' && (
                            <>
                              <motion.div
                                animate={{
                                  scale: [1, 1.3, 1],
                                  opacity: [0.6, 0, 0.6]
                                }}
                                transition={{ duration: 2.5, repeat: Infinity, ease: "easeInOut" }}
                                className={`absolute inset-0 ${isStarredVocabulary ? 'bg-amber-400' : 'bg-purple-400'} rounded-3xl blur-lg -z-10`}
                              />
                              <motion.div
                                animate={{ rotate: 360 }}
                                transition={{ duration: 8, repeat: Infinity, ease: "linear" }}
                                className="absolute inset-0 rounded-3xl -z-10"
                                style={{
                                  background: isStarredVocabulary
                                    ? 'conic-gradient(from 0deg, transparent 0deg, rgba(251, 191, 36, 0.3) 90deg, transparent 180deg)'
                                    : 'conic-gradient(from 0deg, transparent 0deg, rgba(167, 139, 250, 0.3) 90deg, transparent 180deg)',
                                }}
                              />
                            </>
                          )}

                          {/* Success Glow */}
                          {stage.status === 'completed' && (
                            <motion.div
                              animate={{
                                scale: [1, 1.15, 1],
                                opacity: [0.5, 0.8, 0.5]
                              }}
                              transition={{ duration: 3, repeat: Infinity, ease: "easeInOut" }}
                              className="absolute inset-0 bg-emerald-400 rounded-3xl blur-xl -z-10"
                            />
                          )}
                        </motion.button>

                        {/* Enhanced Label */}
                        <motion.div
                          initial={{ opacity: 0, y: 10 }}
                          animate={{ opacity: 1, y: 0 }}
                          transition={{ delay: index * 0.15 + 0.5 }}
                          className="absolute top-[78px] text-center z-20 max-w-[130px]"
                          style={{
                            left:
                              index === 3
                                ? '-15px'
                                : index === 1
                                ? '0px'
                                : index === 0 || index === 2
                                ? '26px'
                                : '36px',
                            transform:
                              index === 1
                                ? 'translateX(-100%)'
                                : index === 3
                                ? 'translateX(-120%)'
                                : 'translateX(-50%)'
                          }}
                        >
                          <div className={`px-2.5 py-1.5 rounded-xl backdrop-blur-lg shadow-md border ${
                            stage.status === 'completed'
                              ? 'bg-emerald-50/95 border-emerald-200/60 text-emerald-700'
                              : stage.status === 'current'
                              ? isStarredVocabulary
                                ? 'bg-white/95 border-amber-200/60 text-amber-700'
                                : 'bg-white/95 border-purple-200/60 text-purple-700'
                              : 'bg-white/80 border-white/40 text-gray-500'
                          }`}>
                            <div className={`text-[11px] ${stage.status === 'completed' ? 'font-semibold' : 'font-medium'}`}>
                              {stage.title}
                            </div>
                          </div>
                        </motion.div>
                      </motion.div>
                    );
                  })}
                </div>

                {/* Enhanced Progress Card - Compact */}
                <motion.div
                  initial={{ opacity: 0, y: 40 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ delay: 1.2, duration: 0.8 }}
                  className="mt-[500px] mx-4 p-5 bg-white/95 backdrop-blur-xl rounded-3xl border-2 border-white/60 shadow-2xl"
                >
                  <div className="text-center space-y-4">
                    <div>
                      <div className="flex items-center justify-center gap-2 mb-1">
                        <Sparkles className={`w-4 h-4 ${isStarredVocabulary ? 'text-amber-500' : 'text-purple-500'}`} />
                        <h3 className={`text-sm ${isStarredVocabulary ? 'text-amber-700' : 'text-purple-700'}`} style={{ fontWeight: 700 }}>Your Progress</h3>
                        <Sparkles className={`w-4 h-4 ${isStarredVocabulary ? 'text-amber-500' : 'text-purple-500'}`} />
                      </div>
                      <p className={`text-xs ${isStarredVocabulary ? 'text-amber-400' : 'text-purple-400'}`}>{journeyName}</p>
                    </div>

                    <div className="flex items-center justify-center gap-6">
                      <div className="text-center">
                        <motion.div
                          initial={{ scale: 0 }}
                          animate={{ scale: 1 }}
                          transition={{ delay: 1.5, type: "spring", stiffness: 200 }}
                          className={`text-2xl bg-gradient-to-br ${isStarredVocabulary ? 'from-amber-600 to-amber-400' : 'from-purple-600 to-purple-400'} bg-clip-text text-transparent mb-1`}
                          style={{ fontWeight: 700 }}
                        >
                          {stages.filter(s => s.status === 'completed').length}
                        </motion.div>
                        <div className={`text-xs ${isStarredVocabulary ? 'text-amber-500' : 'text-purple-500'}`} style={{ fontWeight: 600 }}>Completed</div>
                      </div>
                      <div className={`w-px h-10 bg-gradient-to-b from-transparent ${isStarredVocabulary ? 'via-amber-200' : 'via-purple-200'} to-transparent`}></div>
                      <div className="text-center">
                        <motion.div
                          initial={{ scale: 0 }}
                          animate={{ scale: 1 }}
                          transition={{ delay: 1.6, type: "spring", stiffness: 200 }}
                          className="text-2xl text-gray-300 mb-1"
                          style={{ fontWeight: 700 }}
                        >
                          {stages.filter(s => s.status === 'locked').length}
                        </motion.div>
                        <div className="text-xs text-gray-400" style={{ fontWeight: 600 }}>Remaining</div>
                      </div>
                    </div>

                    <div className="space-y-1.5">
                      <div className={`w-full h-2.5 ${isStarredVocabulary ? 'bg-amber-100/60' : 'bg-purple-100/60'} rounded-full overflow-hidden shadow-inner`}>
                        <motion.div
                          initial={{ width: 0 }}
                          animate={{ width: `${(stages.filter(s => s.status === 'completed').length / stages.length) * 100}%` }}
                          transition={{ delay: 2, duration: 1.5, ease: [0.34, 1.56, 0.64, 1] }}
                          className={`h-full bg-gradient-to-r ${isStarredVocabulary ? 'from-amber-500 via-amber-400 to-amber-500' : 'from-purple-500 via-purple-400 to-purple-500'} rounded-full shadow-lg relative`}
                        >
                          <motion.div
                            animate={{ x: [-20, 100], opacity: [0, 1, 0] }}
                            transition={{ duration: 2, repeat: Infinity, ease: "linear" }}
                            className="absolute inset-0 bg-gradient-to-r from-transparent via-white/40 to-transparent"
                          />
                        </motion.div>
                      </div>
                      <div className={`text-[10px] ${isStarredVocabulary ? 'text-amber-400' : 'text-purple-400'}`} style={{ fontWeight: 600 }}>
                        {Math.round((stages.filter(s => s.status === 'completed').length / stages.length) * 100)}% Complete
                      </div>
                    </div>
                  </div>
                </motion.div>
              </div>
            </motion.div>
          )}

          {activeTab === 'flashcards' && (
            <motion.div
              key="flashcards"
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 20 }}
              transition={{ duration: 0.2 }}
              className="h-full"
            >
              <FlashcardScreen
                onBack={() => setActiveTab('word-list')}
                onBackToHome={onBackToHome}
                vocabularyWords={vocabularyWords}
                starredWordIds={starredWordIds}
                graveyardWordIds={graveyardWordIds}
                vocabularyId={vocabularyId}
                vocabularyTitle={selectedSubject?.name}
                onAddToStarred={onAddToStarred}
                onMoveToGraveyard={onMoveToGraveyard}
                onRefreshVocabulary={refreshVocabulary}
                hideHeader={true}
              />
            </motion.div>
          )}

          {activeTab === 'pdf-print' && canOpenPdfExport && (
            <motion.div
              key="pdf-print"
              initial={{ opacity: 0, x: -20 }}
              animate={{ opacity: 1, x: 0 }}
              exit={{ opacity: 0, x: 20 }}
              transition={{ duration: 0.2 }}
              className="h-full"
            >
              <PDFPrintScreen
                onBack={() => setActiveTab('word-list')}
                vocabularyId={selectedSubject?.id || ''}
                vocabularyTitle={selectedSubject?.name || ''}
                words={vocabularyWords}
                hideHeader={true}
              />
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Quiz Mode Selector Modal - for Quiz Map tab */}
      <AnimatePresence>
        {showQuizModeSelector && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black/40 backdrop-blur-sm z-50 flex items-center justify-center p-6"
            onClick={() => {
              setShowQuizModeSelector(false);
              setPendingStageId(null);
            }}
          >
            <motion.div
              initial={{ scale: 0.8, opacity: 0, y: 20 }}
              animate={{ scale: 1, opacity: 1, y: 0 }}
              exit={{ scale: 0.8, opacity: 0, y: 20 }}
              transition={{ type: "spring", damping: 20 }}
              className="bg-white/95 backdrop-blur-xl rounded-3xl p-6 shadow-2xl border-2 border-white/60 max-w-sm w-full"
              onClick={(e) => e.stopPropagation()}
            >
              <div className="text-center mb-6">
                <h3 className="text-lg mb-1" style={{ fontWeight: 700, color: '#491B6D' }}>
                  ÌÄ¥Ï¶à Î∞©Ïãù ÏÑ†ÌÉù
                </h3>
                <p className="text-xs" style={{ color: '#8B5CF6' }}>
                  ÏõêÌïòÎäî ÌïôÏäµ Î∞©ÏãùÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî
                </p>
              </div>

              {(() => {
                const modalAvailableModes = pendingStageId
                  ? stageModeAvailability[pendingStageId] || ['normal']
                  : [];

                return (
                  <div className="space-y-3">
                    {/* Normal Mode */}
                    {modalAvailableModes.includes('normal') && (
                      <motion.button
                        whileTap={{ scale: 0.95 }}
                        onClick={() => pendingStageId && startQuiz(pendingStageId, 'normal')}
                        className={`w-full p-4 rounded-2xl shadow-lg flex items-center justify-between relative ${
                          pendingStageId && completedModes[pendingStageId]?.has('normal')
                            ? 'bg-gradient-to-br from-emerald-400 to-emerald-600 text-white'
                            : 'bg-gradient-to-br from-[#7C3AED] to-[#A78BFA] text-white'
                        }`}
                      >
                        <div className="flex items-center gap-3">
                          <div className="w-10 h-10 bg-white/20 rounded-xl flex items-center justify-center">
                            <Target className="w-5 h-5" />
                          </div>
                          <div className="text-left">
                            <div className="text-sm" style={{ fontWeight: 700 }}>Normal</div>
                            <div className="text-xs opacity-80">ÏùºÎ∞ò Í∞ùÍ¥ÄÏãù ÌÄ¥Ï¶à</div>
                          </div>
                        </div>
                        {pendingStageId && completedModes[pendingStageId]?.has('normal') ? (
                          <CheckCircle className="w-5 h-5" />
                        ) : (
                          <ChevronRight className="w-5 h-5" />
                        )}
                      </motion.button>
                    )}

                    {/* Match Mode */}
                    {modalAvailableModes.includes('match') && (() => {
                      const poolLength = pendingStageId ? getMatchWordsForStage(pendingStageId).length : 0;
                      const matchDisabled = poolLength < MIN_MATCH_WORDS;
                      return (
                        <motion.button
                          whileTap={{ scale: matchDisabled ? 1 : 0.95 }}
                          onClick={() => {
                            if (matchDisabled || !pendingStageId) return;
                            startQuiz(pendingStageId, 'match');
                          }}
                          className={`w-full p-4 rounded-2xl shadow-md flex items-center justify-between ${
                            matchDisabled
                              ? 'bg-gray-100 border-2 border-dashed border-gray-300 text-gray-400 cursor-not-allowed'
                              : pendingStageId && completedModes[pendingStageId]?.has('match')
                              ? 'bg-gradient-to-br from-emerald-400 to-emerald-600 text-white border-2 border-emerald-300'
                              : 'bg-white border-2 border-[#A78BFA]'
                          }`}
                        >
                          <div className="flex items-center gap-3">
                            <div className={`w-10 h-10 rounded-xl flex items-center justify-center ${
                              matchDisabled
                                ? 'bg-gray-200'
                                : pendingStageId && completedModes[pendingStageId]?.has('match')
                                ? 'bg-white/20'
                                : 'bg-[#EDE9FE]'
                          }`}>
                            <Puzzle className={`w-5 h-5 ${
                              matchDisabled
                                ? 'text-gray-400'
                                : pendingStageId && completedModes[pendingStageId]?.has('match')
                                ? 'text-white'
                                : 'text-[#7C3AED]'
                              }`} />
                            </div>
                            <div className="text-left">
                              <div className="text-sm" style={{
                                fontWeight: 700,
                              color: matchDisabled
                                ? '#9CA3AF'
                                : pendingStageId && completedModes[pendingStageId]?.has('match') ? '#fff' : '#491B6D'
                            }}>
                                Match
                              </div>
                              <div className="text-xs" style={{
                                color: matchDisabled
                                  ? '#9CA3AF'
                                  : pendingStageId && completedModes[pendingStageId]?.has('match') ? 'rgba(255,255,255,0.8)' : '#8B5CF6'
                              }}>
                                {matchDisabled ? `Îã®Ïñ¥Í∞Ä Î∂ÄÏ°±Ìï¥Ïöî (${poolLength}/${MIN_MATCH_WORDS})` : 'Îã®Ïñ¥-Îúª Îß§Ïπ≠ Í≤åÏûÑ'}
                              </div>
                          </div>
                        </div>
                        {pendingStageId && completedModes[pendingStageId]?.has('match') ? (
                          <CheckCircle className="w-5 h-5 text-white" />
                          ) : matchDisabled ? (
                            <span className="text-xs text-gray-400">Ï§ÄÎπÑÏ§ë</span>
                          ) : (
                            <ChevronRight className="w-5 h-5 text-[#7C3AED]" />
                          )}
                        </motion.button>
                      );
                    })()}
                  </div>
                );
              })()}

              <motion.button
                whileTap={{ scale: 0.95 }}
                onClick={() => {
                  setShowQuizModeSelector(false);
                  setPendingStageId(null);
                }}
                className="mt-4 w-full p-3 bg-gray-100 rounded-xl"
              >
                <span className="text-sm" style={{ fontWeight: 600, color: '#6B7280' }}>Ï∑®ÏÜå</span>
              </motion.button>
            </motion.div>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}
